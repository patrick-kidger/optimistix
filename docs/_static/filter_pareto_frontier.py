# Pareto frontier visualisation for the filter line search, initial draft generated by
# Claude. Edited for clarity, brevity and improved visuals.


import jax.numpy as jnp
import jax.random as jr
import matplotlib.animation as animation  # pyright: ignore
import matplotlib.patches as patches  # pyright: ignore
import matplotlib.pyplot as plt  # pyright: ignore
from matplotlib.colors import to_rgba  # pyright: ignore
from matplotlib.lines import Line2D  # pyright: ignore
from PIL import Image, ImageSequence


def create_pareto_frontier_gif(
    filename: str, n_points=50, interval=200, figsize=(10, 10)
):
    points = jr.uniform(jr.key(0), (n_points, 2), minval=0, maxval=1)
    sorted_points = points[jnp.argsort(-jnp.sqrt(jnp.sum(points**2, axis=1)))]

    # Create figure and axis
    fig, ax = plt.subplots(figsize=figsize)

    # Set plot limits and labels
    ax.set_xlim(0, 1)
    ax.set_ylim(0, 1)
    ax.tick_params(axis="both", which="major", labelsize=18)
    ax.set_xticks([0, 1])
    ax.set_yticks([0, 1])
    ax.set_xticklabels(["low", "high"])
    ax.set_yticklabels(["", "high"])
    ax.set_aspect("equal", adjustable="box")
    ax.set_xlabel("Objective function value", fontsize=20)
    ax.set_ylabel("Constraint violation", fontsize=20)
    ax.set_title("Accepted steps define the Pareto frontier", fontsize=24)

    blocked_region_color = "orangered"
    blocked_region_shade = to_rgba(blocked_region_color, 0.1)
    acceptable_region_color = "lightseagreen"

    legend_elements = [
        Line2D(
            [0],
            [0],
            marker="o",
            color=acceptable_region_color,
            label="Accepted",
            markerfacecolor=acceptable_region_color,
            markersize=8,
            linestyle="",
        ),
        patches.Patch(
            facecolor=blocked_region_shade,
            edgecolor=blocked_region_color,
            label="Blocked",
            linestyle="--",
        ),
    ]
    ax.legend(handles=legend_elements, loc="lower left", prop={"size": 16})

    # Initialize empty lists for animation
    point_artists = []
    patch_artists = []

    # Function to initialize the animation
    def init():
        return []

    # Function to update the animation for each frame
    def update(frame):
        if frame == 0:
            # Clear everything when starting over
            for artist in point_artists + patch_artists:
                artist.remove() if artist in ax.get_children() else None
            point_artists.clear()
            patch_artists.clear()

        current_point_x, current_point_y = sorted_points[frame]
        point_artist, *_ = ax.plot(
            current_point_x,
            current_point_y,
            "o",
            markersize=8,
            color=acceptable_region_color,
        )
        point_artists.append(point_artist)

        # Add the dominated region as a semi-transparent rectangle
        patch = patches.Rectangle(
            (current_point_x, current_point_y),
            1 - current_point_x,
            1 - current_point_y,
            facecolor=blocked_region_shade,
            edgecolor=blocked_region_color,
            linestyle="--",
            linewidth=1,
        )
        ax.add_patch(patch)
        patch_artists.append(patch)

        # Check if any previous points are now dominated by the current point
        for artist in point_artists[:-1]:  # Skip the current point
            prev_point_x, prev_point_y = artist.get_data()

            # Check if the previous point is dominated by current point
            # A point is dominated if another point is better (lower) in all dimensions
            if current_point_x <= prev_point_x and current_point_y <= prev_point_y:
                # At least one dimension must be strictly better
                if current_point_x < prev_point_x or current_point_y < prev_point_y:
                    artist.set_color(blocked_region_color)

        # Return all artists that need to be updated
        return point_artists + patch_artists

    # Create animation
    anim = animation.FuncAnimation(
        fig,
        update,
        frames=len(sorted_points),
        init_func=init,
        blit=False,
        interval=interval,
    )

    # Save as GIF
    anim.save(filename, writer="pillow")

    return fig, ax, anim


def add_padding_to_gif(
    input_path,
    output_path,
    left=0,
    right=0,
    top=0,
    bottom=0,
    bg_color=(255, 255, 255, 0),
):
    img = Image.open(input_path)

    # Get dimensions
    original_width, original_height = img.size
    new_width = original_width + left + right
    new_height = original_height + top + bottom

    # Process each frame
    frames = []
    durations = []

    for frame in ImageSequence.Iterator(img):
        frame_rgba = frame.convert("RGBA")
        padded_frame = Image.new("RGBA", (new_width, new_height), bg_color)
        padded_frame.paste(frame_rgba, (left, top), frame_rgba)
        if img.mode != "RGBA":
            padded_frame = padded_frame.convert(img.mode)
        frames.append(padded_frame)

        try:
            durations.append(frame.info["duration"])
        except KeyError:
            durations.append(100)  # Default duration if not specified

    # Save the padded GIF
    frames[0].save(
        output_path,
        format="GIF",
        append_images=frames[1:],
        save_all=True,
        duration=durations,
        loop=img.info.get("loop", 0),
        disposal=2,  # This helps with transparency
        optimize=False,
    )

    print(f"Padded GIF saved to {output_path}")


if __name__ == "__main__":
    filename = "filter_pareto_frontier.gif"
    fig, ax, anim = create_pareto_frontier_gif(filename, n_points=30, interval=300)
    plt.close(fig)
    print("Animation saved as {}".format(filename))
    add_padding_to_gif(filename, filename, left=600, right=600)
